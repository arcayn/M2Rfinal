

# This file was *autogenerated* from the file AG/algeom.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_15 = Integer(15); _sage_const_4318 = Integer(4318); _sage_const_0 = Integer(0); _sage_const_10 = Integer(10); _sage_const_4319 = Integer(4319); _sage_const_50 = Integer(50); _sage_const_2000 = Integer(2000); _sage_const_5 = Integer(5); _sage_const_75 = Integer(75); _sage_const_1000 = Integer(1000); _sage_const_11 = Integer(11); _sage_const_8 = Integer(8); _sage_const_16 = Integer(16)# this file will randomly generate polytopes and output them in plucker coordinate
# form

import random
import itertools


def plucker(P, vl=None):
    #M1 = Matrix([[1,1],[0,1]])
    if vl is None: vl = list(P.vertices())
    M_ = Matrix([b for b in vl]).transpose()
    M = M_.right_kernel().matrix()
    rows,_ = M.dimensions()
    minors = M.minors(rows)
    return ProjectiveSpace(len(minors) - _sage_const_1 , ZZ)(minors)

def gen_all_plucker(dim):
    assert dim in (_sage_const_2 , _sage_const_3 )
    for idx in range(_sage_const_15  if dim == _sage_const_2  else _sage_const_4318 ):
        pt = ReflexivePolytope(dim, idx)
        if pt.lattice().submodule(pt.vertices()).index_in(pt.lattice()) != _sage_const_1 :
            continue
        for vl in itertools.permutations(list(pt.vertices())):
            yield (plucker(pt, vl), idx)
    return

def graph_embedding(P):
    vl = list(P.vertices())
    edges = [f.vertices() for f in P.faces()[_sage_const_2 ]]
    edges = [(e[_sage_const_0 ], e[_sage_const_1 ]) for e in edges]
    weights = [abs(e[_sage_const_1 ] - e[_sage_const_0 ]) for e in edges]
    edges_anon = [sorted([vl.index(x), vl.index(y)]) for x,y in edges]

    return [list([(a,b,c) for a,b,c in vl]), sorted([(a[_sage_const_0 ], a[_sage_const_1 ], b) for a,b in zip(edges_anon, weights)])]

def flatten2d(l):
    r = []
    for ll in l: r += ll
    return r

def face_graph_embedding(P):
    faces = flatten2d(P.faces())
    adjacency = [[_sage_const_0  for _ in faces] for _ in faces]
    for i,f1 in enumerate(faces):
        for j,f2 in enumerate(faces):
            if f1.dim() == f2.dim() + _sage_const_1  and f2 in flatten2d(f1.faces()):
                adjacency[i][j] = _sage_const_1 
                adjacency[j][i] = _sage_const_1 
    
    return adjacency

def vertex_matrix_embedding(P):
    vl = list(P.vertices())
    l = [list(v) + [_sage_const_0 ] * _sage_const_10  for v in vl]
    for ray in P.faces()[-_sage_const_3 ]:
        v1,v2 = ray.vertices()
        l[vl.index(v1)][_sage_const_3 +vl.index(v2)] = _sage_const_1 
        l[vl.index(v2)][_sage_const_3 +vl.index(v1)] = _sage_const_1 

    return str(l)

def map_lattice_pt(pt, M, permute=True):
    V = [M * v for v in pt.vertices()]
    random.shuffle(V)
    return LatticePolytope(V)

def make_polytope_sample_train():
    r = []
    for x in range(_sage_const_4319 ):
        print (x)
        base_pt = ReflexivePolytope(_sage_const_3 , x)
        if len(base_pt.vertices()) != _sage_const_10 :
            continue
        for _ in range(_sage_const_50 ):
            M = random_matrix(ZZ,_sage_const_3 ,_sage_const_3 )
            while abs(M.det()) != _sage_const_1 :
                M = random_matrix(ZZ,_sage_const_3 ,_sage_const_3 )
            pt = map_lattice_pt(base_pt, M)
            gpt = [vertex_matrix_embedding(pt), x]
            r.append(str(gpt) + "\n")
    
    with open("data/train_matrices.txt", "w") as f:
        f.writelines(r)

def make_polytope_sample_test():
    r = []
    import random
    for _ in range(_sage_const_2000 ):
        x = random.randint(_sage_const_0 , _sage_const_4318 )
        base_pt = ReflexivePolytope(_sage_const_3 , x)
        while len(base_pt.vertices()) != _sage_const_10 :
            x = random.randint(_sage_const_0 , _sage_const_4318 )
            base_pt = ReflexivePolytope(_sage_const_3 , x)
        M = random_matrix(ZZ,_sage_const_3 ,_sage_const_3 )
        while abs(M.det()) != _sage_const_1 :
            M = random_matrix(ZZ,_sage_const_3 ,_sage_const_3 )
        pt = map_lattice_pt(base_pt, M)
        gpt = [vertex_matrix_embedding(pt), x]
        r.append(str(gpt) + "\n")
    
    with open("data/test_matrices.txt", "w") as f:
        f.writelines(r)

make_polytope_sample_test()
make_polytope_sample_train()

def gen_whole_plucker_sample(dim):
    assert dim in (_sage_const_2 , _sage_const_3 )
    r = []
    for idx in range(_sage_const_15  if dim == _sage_const_2  else _sage_const_4318 ):
        pt = ReflexivePolytope(dim, idx)
        if pt.lattice().submodule(pt.vertices()).index_in(pt.lattice()) != _sage_const_1 :
            continue
            
        rr = set()
        for vl in itertools.permutations(list(pt.vertices())):
            rr.add(plucker(pt, vl))
        r.append((rr,idx))
    return r

def gen_random_plucker_sample(dim):
    assert dim in (_sage_const_2 , _sage_const_3 )

    r = []
    for idx in range(_sage_const_15  if dim == _sage_const_2  else _sage_const_4318 ):
        print (idx)
        pt = ReflexivePolytope(dim, idx)
        if pt.lattice().submodule(pt.vertices()).index_in(pt.lattice()) != _sage_const_1 :
            continue
        if len(pt.vertices()) < _sage_const_5 :
            continue
        
        rr = set()
        if len(pt.vertices()) <= _sage_const_5 :
            for vl in itertools.permutations(list(pt.vertices())):
                rr.add(plucker(pt, vl))
        else:
            print ("H")
            t = list(pt.vertices())
            random.shuffle(t)
            cnt = _sage_const_0 
            while len(rr) < _sage_const_75 :
                rr.add(plucker(pt, t))
                random.shuffle(t)
                cnt += _sage_const_1 
                if cnt > _sage_const_1000 :
                    print ("BAD", cnt)
                    break
        
        if len(rr) < _sage_const_75 :
            continue
        rl = random.sample(list(rr), _sage_const_75 )
        
        r.append((rl, idx))
    return r


def gen_reflexive_polytope(dim):
    # will work on generating arbitrary reflexive polytopes
    # but for now we focus on generating isomorphisms to the PALP db
    assert dim in (_sage_const_2 , _sage_const_3 )

    idx = random.randint(_sage_const_0 , _sage_const_15  if dim == _sage_const_2  else _sage_const_4318 )
    base_pt = ReflexivePolytope(dim, idx)
    """
    transform = [random.randint(0, 100) for _ in range(dim + 1)]

    pt = base_pt
    for e,M in zip(transform, GL(dim, ZZ).as_matrix_group().gens()):
        pt = map_lattice_pt(pt, (M ^ e)) 
    """

    M = random_matrix(ZZ,dim,dim)
    while abs(M.det()) != _sage_const_1 :
        M = random_matrix(ZZ,dim,dim)
    pt = map_lattice_pt(base_pt, M)
    
    # make sure we have actually performed a CoB
    assert pt.index() == idx
    return pt, idx

def gen_primitive_polytope(dim, n):
    assert n >= dim + _sage_const_1 


def write_plucker_sample(dim):
    sample = gen_whole_plucker_sample(dim)
    sample = [[[list(s) for s in S],i] for S,i in sample]
    print (sample)
    with open("plucker_s.txt", "wb") as f:
        f.write(str(sample).encode())

def plotPoly(P):
    rad = _sage_const_3 
    plot = [[' ' for _ in range(_sage_const_2  * rad + _sage_const_1 )] for _ in range(_sage_const_2  * rad + _sage_const_1 )]
    for x,y in P.vertices():
        plot[rad - y][rad + x] = '.'
    plot[rad][rad] = 'O'
    for pp in plot:
        print (''.join(pp))

plotPoly(ReflexivePolytope(_sage_const_2 , _sage_const_11 ))
plotPoly(ReflexivePolytope(_sage_const_2 , _sage_const_8 ))
for i in range(_sage_const_16 ):
    print (i, plucker(ReflexivePolytope(_sage_const_2 , i)))

